// this file is intended to be an example of how SigningKey can be implemented using different key storage/generation mechanisms

import { exists, writeFile } from 'node:fs/promises';
import { exec } from 'node:child_process';
import crypto from 'node:crypto';

import { type Signer } from '../contracts/key';
import { readFile } from 'node:fs/promises';
import {
	type DataType,
	type EncryptionValidAlgorithm,
	type SignatureType,
} from '../constants';

export type SshKeygenSigningKeyConfig = {
	// path to the private key file generated by ssh-keygen
	privateKeyPath?: string;
	// path to the public key file generated by ssh-keygen
	publicKeyPath?: string;

	configDir: string;
};

async function loadKey(path: string): Promise<Uint8Array> {
	const data = await readFile(path);
	return data;
}

type Key = { privateKey: Buffer; publicKey: Buffer };

async function loadKeys(
	privateKeyPath: string,
	publicKeyPath: string,
): Promise<Key> {
	const sk = await loadKey(privateKeyPath);
	const pk = await loadKey(publicKeyPath);

	return { privateKey: Buffer.from(sk), publicKey: Buffer.from(pk) };
}

export class SshKeygenSigningKey implements Signer {
	public version = '0';
	public constructor(private readonly config: SshKeygenSigningKeyConfig) {}

	public algorithm = 'rsa' as EncryptionValidAlgorithm;

	private privateKey?: Buffer;
	private publicKey?: Buffer;

	private setkey(key: Key) {
		this.privateKey = key.privateKey;
		this.publicKey = key.publicKey;
	}

	public async load(): Promise<void> {
		const { privateKeyPath, publicKeyPath, configDir } = this.config;

		const algorithm = this.algorithm;

		if (!privateKeyPath || !publicKeyPath) {
			// we generate the keys ourselves
			// must be mac or linux for this
			if (process.platform !== 'darwin' && process.platform !== 'linux') {
				throw new Error(
					'ssh-keygen signing key without provided keys is only supported on macOS and Linux',
				);
			}

			if (!configDir) {
				throw new Error('configDir must be provided if keys are not provided');
			}

			// set some defaults
			const sk = `${configDir}/id_${algorithm}` as const;
			const pk = `${sk}.pub` as const;

			// maybe they exist in the configDir already
			const skExists = await exists(sk);
			const pkExists = await exists(pk);

			// both must exist or not exist
			if (skExists !== pkExists) {
				throw new Error(
					'Both private and public key files must exist or not exist',
				);
			}

			// both exists, we load them
			if (skExists) {
				// TODO: handle loading this
				const key = await loadKeys(sk, pk);

				this.setkey(key);
				return;
			}
			// doesn't exist, generate
			const key: Key = await new Promise((resolve, reject) =>
				exec(
					// biome-ignore lint/style/useTemplate: <explanation>
					'ssh-keygen' + // using ssh-keygen
						' -m PEM' + // export to PEM format, which crypto library will need, technically not a limitatiion for the IDEA of a SigningKey
						' -N ""' + // no passphrase
						' -t ' +
						algorithm + // == rsa, needed for PEM export easily
						' -f ' +
						sk, // file to write the private key to
					async (error, _stdout, stderr) => {
						if (error) {
							console.error(`Error generating ssh keys: ${error.message}`);
							reject(error);
						}
						if (stderr) {
							reject(`ssh-keygen stderr: ${stderr}`);
						}

						// need public key in PEM format too, so we convert it
						await new Promise((resolve, reject) =>
							exec(`ssh-keygen -f ${pk} -e -m PEM`, (error, stdout, stderr) => {
								if (error) {
									console.error(
										`Error generating public key PEM: ${error.message}`,
									);
									reject(error);
								}
								if (stderr) {
									reject(`ssh-keygen stderr: ${stderr}`);
								}

								// ssh-keygen sends the pem to stdout, we overwrite existikng pk with it
								writeFile(pk, stdout).then(() =>
									// write the public key PEM to a file
									resolve({}),
								);
							}),
						);

						// load the generated keys
						const key = await loadKeys(sk, pk);
						resolve(key);
					},
				),
			);

			this.setkey(key);
			return;
		}

		// both keys are provided, we load them
		const key = await loadKeys(privateKeyPath, publicKeyPath);

		this.setkey(key);
	}

	async sign(data: DataType): Promise<SignatureType> {
		if (!this.privateKey) {
			throw new Error('Private key not loaded');
		}

		const dataLike = typeof data === 'string' ? Buffer.from(data) : data;
		const signature = await crypto.sign('sha256', dataLike, this.privateKey);

		return signature;
	}

	async verify(data: DataType, signature: SignatureType): Promise<void> {
		const dataLike = typeof data === 'string' ? Buffer.from(data) : data;
		return new Promise((resolve, reject) => {
			if (!this.publicKey) {
				reject('Public key not loaded');
				return;
			}

			crypto.verify('sha256', dataLike, this.publicKey, signature, (error) => {
				if (error) {
					reject(error);
				}

				resolve();
			});
		});
	}
}
