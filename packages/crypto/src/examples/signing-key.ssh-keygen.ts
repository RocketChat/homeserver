// this file is intended to be an example of how SigningKey can be implemented using different key storage/generation mechanisms

import { exists, writeFile } from 'node:fs/promises';
import { exec } from 'node:child_process';
import crypto from 'node:crypto';

import {
	EncryptionValidAlgorithm,
	GenerateSigningKeyFunc,
	SigningKey,
} from '../signing-key';
import { readFile } from 'node:fs/promises';

export type SshKeygenSigningKeyConfig = {
	// path to the private key file generated by ssh-keygen
	privateKeyPath?: string;
	// path to the public key file generated by ssh-keygen
	publicKeyPath?: string;

	configDir: string;
};

async function loadKey(path: string): Promise<Uint8Array> {
	const data = await readFile(path);
	return data;
}

function getSigningKeyFunc({
	privateKeyPath,
	publicKeyPath,
	configDir,
}: SshKeygenSigningKeyConfig): GenerateSigningKeyFunc {
	return async (): Promise<SigningKey> => {
		if (!privateKeyPath || !publicKeyPath) {
			// we generate the keys ourselves
			// must be mac or linux for this
			if (process.platform !== 'darwin' && process.platform !== 'linux') {
				throw new Error(
					'ssh-keygen signing key without provided keys is only supported on macOS and Linux',
				);
			}

			if (!configDir) {
				throw new Error('configDir must be provided if keys are not provided');
			}

			// set some defaults
			const privateKeyPath = `${configDir}/id_ed25519` as const;
			const publicKeyPath = `${configDir}/id_ed25519.pub` as const;

			// maybe they exist in the configDir already
			const privateKeyExists = await exists(privateKeyPath);
			const publicKeyExists = await exists(publicKeyPath);

			// both must exist or not exist
			if (privateKeyExists !== publicKeyExists) {
				throw new Error(
					'Both private and public key files must exist or not exist',
				);
			}

			type Key = { privateKey: Uint8Array; publicKey: Uint8Array };

			// both exists, we load them
			if (privateKeyExists) {
				// TODO: handle loading this
				const key: Key = await loadKey(privateKeyPath).then((privateKey) =>
					loadKey(publicKeyPath).then((publicKey) => ({
						privateKey,
						publicKey,
					})),
				);

				return new SshKeygenSigningKey(key.privateKey, key.publicKey);
			}
			// doesn't exist, generate
			const key: Key = await new Promise((resolve, reject) =>
				exec(
					`ssh-keygen -m PEM -N "" -t rsa -f ${privateKeyPath} -C "generaetd"`,
					async (error, _stdout, stderr) => {
						if (error) {
							console.error(`Error generating ssh keys: ${error.message}`);
							reject(error);
						}
						if (stderr) {
							reject(`ssh-keygen stderr: ${stderr}`);
						}

						await new Promise((resolve, reject) =>
							exec(
								`ssh-keygen -f ${publicKeyPath} -e -m PEM`,
								(error, stdout, stderr) => {
									if (error) {
										console.error(
											`Error generating public key PEM: ${error.message}`,
										);
										reject(error);
									}
									if (stderr) {
										reject(`ssh-keygen stderr: ${stderr}`);
									}

									writeFile(publicKeyPath, stdout).then(() =>
										// write the public key PEM to a file
										resolve({}),
									);
								},
							),
						);

						// load the generated keys
						loadKey(privateKeyPath).then((privateKey) =>
							loadKey(publicKeyPath).then((publicKey) =>
								resolve({ privateKey, publicKey }),
							),
						);
					},
				),
			);

			return new SshKeygenSigningKey(key.privateKey, key.publicKey);
		}

		// both keys are provided, we load them
		const key: { privateKey: Uint8Array; publicKey: Uint8Array } =
			await loadKey(privateKeyPath).then((privateKey) =>
				loadKey(publicKeyPath).then((publicKey) => ({
					privateKey,
					publicKey,
				})),
			);

		return new SshKeygenSigningKey(key.privateKey, key.publicKey);
	};
}

export const getSshKeygenSigningKey = getSigningKeyFunc({ configDir: '/tmp' });

export class SshKeygenSigningKey implements SigningKey {
	public algorithm = EncryptionValidAlgorithm.ed25519;
	public version = '0';
	public constructor(
		private readonly privateKey: Uint8Array,
		private readonly publicKey: Uint8Array,
	) {}

	async sign(data: string | Buffer): Promise<Buffer> {
		const signature = await crypto.sign(
			'sha256',
			Buffer.isBuffer(data) ? data : Buffer.from(data),
			this.privateKey.toString(),
		);
		return signature;
	}

	async verify(data: string, signature: Buffer): Promise<boolean> {
		return new Promise((resolve, reject) =>
			crypto.verify(
				'sha256',
				Buffer.from(data),
				this.publicKey.toString(),
				signature,
				(error) => {
					if (error) {
						reject(error);
					}

					resolve(true);
				},
			),
		);
	}
}
