import { Elysia, t } from "elysia";

import { isConfigContext } from "../../plugins/isConfigContext";
import { isMongodbContext } from "../../plugins/isMongodbContext";
import { isRoomMemberEvent } from "@hs/core/src/events/m.room.member";
import type { SignedEvent } from "../../signJson";
import type { EventBase } from "@hs/core/src/events/eventBase";
import type { HashedEvent } from "../../authentication";

// PUT uri: `/_matrix/federation/v1/send_join/${params.roomId}/${event.state_key}?omit_members=true`,

export const sendJoinV2Route = new Elysia().put(
	"/send_join/:roomId/:stateKey",
	async ({ params, body, ...context }) => {
		if (!isConfigContext(context)) {
			throw new Error("No config context");
		}
		if (!isMongodbContext(context)) {
			throw new Error("No mongodb context");
		}
		const {
			config,
			mongo: { eventsCollection },
		} = context;

		const roomId = decodeURIComponent(params.roomId);
		const stateKey = decodeURIComponent(params.stateKey);
		const event = body as SignedEvent<HashedEvent<EventBase>>;

		console.log("sendJoin ->", { roomId, stateKey });
		console.log("sendJoin ->", { body });

		const records = await eventsCollection
			.find({ "event.room_id": roomId }, { sort: { "event.depth": 1 } })
			.toArray();

		const events = records.map((event) => event.event);

		const lastInviteEvent = records.find(
			(record) =>
				isRoomMemberEvent(record.event) &&
				record.event.content.membership === "invite",
			// event.state_key === stateKey,
		);

		// console.log("lastEvent ->", lastEvent);

		// const joinEvent = events.pop();
		const result = {
			event: {
				...event,
				unsigned: lastInviteEvent && {
					replaces_state: lastInviteEvent._id,
					prev_content: lastInviteEvent.event.content,
					prev_sender: lastInviteEvent.event.sender,
				},
			} as SignedEvent<HashedEvent<EventBase>>,
			state: events,
			auth_chain: events.filter((event) => event.depth <= 4),
			// auth_chain: [],
			members_omitted: false,
			origin: config.name,
		} as const;

		console.log("sendJoin result ->", result);

		if (!(await eventsCollection.findOne({ _id: stateKey }))) {
			await eventsCollection.insertOne({
				_id: stateKey,
				event,
			});
		}

		return result;
	},
	{
		// body: t.Object({
		// 	type: t.Literal("m.room.member"),
		// 	state_key: t.String(),
		// 	sender: t.String(),
		// 	origin_server_ts: t.Number(),
		// 	origin: t.String(),
		// 	content: t.Object({
		// 		membership: t.String(),
		// 	}),
		// 	depth: t.Number(),
		// 	room_id: t.String(),
		// 	auth_events: t.Array(t.String()),
		// 	prev_events: t.Array(t.String()),
		// 	unsigned: t.Object({
		// 		aget_ts: t.Number()
		// 	})
		// }),
		params: t.Object(
			{
				roomId: t.String({
					// description: "The room ID that the user is being invited to.",
				}),
				stateKey: t.String({
					// description:
					// 	"The user ID for the invite event, generated by the inviting server.",
				}),
			},
			{
				examples: [
					{
						roomId: "!abc123:matrix.org",
						userId: "@admin:example.org",
					},
				],
			},
		),
		detail: {
			security: [
				{
					matrixAuth: [],
				},
			],
		},
	},
);
